// Prisma schema for Accounting + Inventory ERP (SQLite compatible)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Enums

enum Role {
  ADMIN
  ACCOUNTANT
  INVENTORY
  OWNER
}

enum AccountCategory {
  ASSET
  LIABILITY
  EQUITY
  INCOME
  EXPENSE
}

enum MovementType {
  IN
  OUT
  ADJUSTMENT
}

enum ReferenceType {
  SALES_INVOICE
  PURCHASE_BILL
  PAYMENT
  ADJUSTMENT
  MANUAL
}

enum InvoiceStatus {
  DRAFT
  POSTED
  PAID
  PARTIALLY_PAID
}

enum BillStatus {
  DRAFT
  POSTED
  PAID
  PARTIALLY_PAID
}

enum PaymentType {
  IN
  OUT
}

// Permission system enums

enum PermissionAction {
  VIEW
  CREATE
  EDIT
  DELETE
}

enum PermissionResource {
  APPOINTMENTS
  CLIENTS
  INVOICES
  PAYMENTS
  JOBCARDS
  SUPPLIERS
  PURCHASES
  GOODS_RECEIVED
  EXPENSES
  PRODUCTS
  ADJUSTMENTS
  TRANSFERS
  BANKING
  REPORTS
  SETTINGS
}

// Core models

model User {
  id             String         @id @default(cuid())
  email          String         @unique
  passwordHash   String
  name           String
  role           Role           @default(ACCOUNTANT)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  journalEntries JournalEntry[] @relation("UserJournalEntries")
}

model RolePermission {
  id        String             @id @default(cuid())
  role      Role
  resource  PermissionResource
  action    PermissionAction
  createdAt DateTime           @default(now())

  @@unique([role, resource, action])
}

model Account {
  id        String           @id @default(cuid())
  code      String           @unique
  name      String
  category  AccountCategory
  isActive  Boolean          @default(true)
  parentId  String?
  parent    Account?         @relation("AccountToParent", fields: [parentId], references: [id])
  children  Account[]        @relation("AccountToParent")
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  // Relations
  journalLines       JournalLine[]
  // Product account mappings
  productsInventory  Product[]     @relation("ProductInventoryAccount")
  productsCogs       Product[]     @relation("ProductCogsAccount")
  productsRevenue    Product[]     @relation("ProductRevenueAccount")
  // AR/AP/Revenue on documents
  salesInvoicesAR    SalesInvoice[] @relation("InvoiceAR")
  salesInvoicesRev   SalesInvoice[] @relation("InvoiceRevenue")
  purchaseBillsAP    PurchaseBill[] @relation("BillAP")
  // Payments & reconciliation
  paymentsBank       Payment[]      @relation("PaymentBank")
  paymentsAR         Payment[]      @relation("PaymentAR")
  paymentsAP         Payment[]      @relation("PaymentAP")
  bankReconciliations BankReconciliation[] @relation("ReconcileBank")
}

model JournalEntry {
  id            String        @id @default(cuid())
  date          DateTime
  memo          String?
  posted        Boolean       @default(true)
  createdById   String
  createdBy     User          @relation("UserJournalEntries", fields: [createdById], references: [id])
  referenceType ReferenceType
  referenceId   String?
  createdAt     DateTime      @default(now())
  lines         JournalLine[]
  // Back-relations for documents and movements
  salesInvoices  SalesInvoice[]
  purchaseBills  PurchaseBill[]
  payments       Payment[]
  stockMovements StockMovement[]
}

model JournalLine {
  id          String        @id @default(cuid())
  entryId     String
  entry       JournalEntry  @relation(fields: [entryId], references: [id])
  accountId   String
  account     Account       @relation(fields: [accountId], references: [id])
  description String?
  debit       Decimal       // No native @db.Decimal to keep SQLite compatible
  credit      Decimal
  productId   String?
  product     Product?      @relation(fields: [productId], references: [id])
  locationId  String?
  location    StockLocation? @relation(fields: [locationId], references: [id])
}

model Product {
  id                 String    @id @default(cuid())
  sku                String    @unique
  name               String
  description        String?
  unitOfMeasure      String    @default("unit")
  price              Decimal
  cost               Decimal
  isActive           Boolean   @default(true)
  reorderPoint       Int       @default(0)
  inventoryAccountId String
  inventoryAccount   Account   @relation("ProductInventoryAccount", fields: [inventoryAccountId], references: [id])
  cogsAccountId      String
  cogsAccount        Account   @relation("ProductCogsAccount", fields: [cogsAccountId], references: [id])
  revenueAccountId   String
  revenueAccount     Account   @relation("ProductRevenueAccount", fields: [revenueAccountId], references: [id])
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  // Relations
  invoiceItems       SalesInvoiceItem[]
  billItems          PurchaseBillItem[]
  stockMovements     StockMovement[]
  journalLines       JournalLine[]
}

model StockLocation {
  id        String          @id @default(cuid())
  code      String          @unique
  name      String
  isActive  Boolean         @default(true)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  movements StockMovement[]
  // Back-relations
  salesItems       SalesInvoiceItem[]
  purchaseBillItems PurchaseBillItem[]
  journalLines     JournalLine[]
}

model StockMovement {
  id             String        @id @default(cuid())
  productId      String
  product        Product       @relation(fields: [productId], references: [id])
  locationId     String
  location       StockLocation @relation(fields: [locationId], references: [id])
  date           DateTime      @default(now())
  movementType   MovementType
  quantity       Decimal
  costPerUnit    Decimal
  referenceType  ReferenceType
  referenceId    String?
  journalEntryId String?
  journalEntry   JournalEntry? @relation(fields: [journalEntryId], references: [id])
}

model SalesInvoice {
  id              String             @id @default(cuid())
  number          String             @unique
  date            DateTime
  customerName    String
  status          InvoiceStatus      @default(DRAFT)
  arAccountId     String
  arAccount       Account            @relation("InvoiceAR", fields: [arAccountId], references: [id])
  revenueAccountId String?
  revenueAccount   Account?          @relation("InvoiceRevenue", fields: [revenueAccountId], references: [id])
  postedEntryId   String?
  postedEntry     JournalEntry?      @relation(fields: [postedEntryId], references: [id])
  items           SalesInvoiceItem[]
  total           Decimal
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
}

model SalesInvoiceItem {
  id          String         @id @default(cuid())
  invoiceId   String
  invoice     SalesInvoice   @relation(fields: [invoiceId], references: [id])
  productId   String
  product     Product        @relation(fields: [productId], references: [id])
  description String?
  locationId  String
  location    StockLocation  @relation(fields: [locationId], references: [id])
  quantity    Decimal
  unitPrice   Decimal
  unitCost    Decimal
  lineTotal   Decimal
}

model PurchaseBill {
  id              String        @id @default(cuid())
  number          String        @unique
  date            DateTime
  vendorName      String
  status          BillStatus    @default(DRAFT)
  apAccountId     String
  apAccount       Account       @relation("BillAP", fields: [apAccountId], references: [id])
  postedEntryId   String?
  postedEntry     JournalEntry? @relation(fields: [postedEntryId], references: [id])
  items           PurchaseBillItem[]
  total           Decimal
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

model PurchaseBillItem {
  id          String        @id @default(cuid())
  billId      String
  bill        PurchaseBill  @relation(fields: [billId], references: [id])
  productId   String
  product     Product       @relation(fields: [productId], references: [id])
  description String?
  locationId  String
  location    StockLocation @relation(fields: [locationId], references: [id])
  quantity    Decimal
  unitCost    Decimal
  lineTotal   Decimal
}

model Payment {
  id             String        @id @default(cuid())
  date           DateTime      @default(now())
  amount         Decimal
  type           PaymentType
  bankAccountId  String
  bankAccount    Account       @relation("PaymentBank", fields: [bankAccountId], references: [id])
  arAccountId    String?
  arAccount      Account?      @relation("PaymentAR", fields: [arAccountId], references: [id])
  apAccountId    String?
  apAccount      Account?      @relation("PaymentAP", fields: [apAccountId], references: [id])
  referenceType  ReferenceType
  referenceId    String?
  journalEntryId String?
  journalEntry   JournalEntry? @relation(fields: [journalEntryId], references: [id])
  reconciled     Boolean       @default(false)
  // Back-relations
  reconciliationLines ReconciliationLine[]
}

model BankReconciliation {
  id            String    @id @default(cuid())
  bankAccountId String
  bankAccount   Account   @relation("ReconcileBank", fields: [bankAccountId], references: [id])
  statementDate DateTime
  endingBalance Decimal
  notes         String?
  createdAt     DateTime  @default(now())
  lines         ReconciliationLine[]
}

model ReconciliationLine {
  id               String             @id @default(cuid())
  reconciliationId String
  reconciliation   BankReconciliation @relation(fields: [reconciliationId], references: [id])
  paymentId        String
  payment          Payment            @relation(fields: [paymentId], references: [id])
}
